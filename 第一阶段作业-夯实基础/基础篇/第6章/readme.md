# static,final和常量设计
## static
静态成员，类共有成员
不依赖于实例化对象存在，只依赖类而存在
可以通过类名调用
静态方法也一样，不依赖于对象，依赖于类
静态方法不能引用非静态方法和非静态变量

## static代码块
静态代码块只在类被调用加载时执行唯一一次
```
static{
    //...
}
```
而匿名代码块在创建对象时都会执行一次
```
{
    //...
}
```
执行顺序：static > 匿名 > 构造函数

## 单例模式
限定某一个类在程序运行时，只能有一个实例化对象
* 采用static来共享对象实例
* 采用private构造函数，防止外界操作

## final
final关键字可以用来修饰类，方法，字段
* final修饰的类不能被继承
* 父类中如果有final修饰的方法，子类则不能重写这个方法
* final的变量不能被二次赋值，基本类型不能修改值，对象实例不能修改内存地址即指针，但是可以修改对象里属性的值

# 常量设计
例如
```public final static int NUM = 4;```
常量命名建议全大写，以连字符连接
* 一种特殊的常量：接口里定义的变量默认是常量；

# 常量池
相同的值只存储一份，Java提供了很多基本类型的包装类还有字符串这些都建立了常量池
不过对于基本类型的包装类常量池对于存储的值有范围要求
Byte，Integer，Short，Long都是-128~127
Character是0~127 

常量式赋值创建，存储在栈空间
```
Integer a = 10；
String b = "abc";
```
new对象创建，存储在堆内存
```
Integer a = new Integer(10);
String b = new String("abc");
```
两类创建方式存储的内存位置不同

# 不可变对象
一旦创建，这个对象的值状态就不能被更改
8个基本类型的包装类，例如
```
String a = new String("abc");
String b = a;
a = "def";
System.out.println(a);
System.out.println(b);
 ```
a和b的值输出是不一样的，在a=“def”出会重新创建一块内存存储"def"
在这个例子中也就是a先前指向的对象"abc"是不可改变的，但是指针a的指向是可以改变的

## 如何创建不可变对象 
* 所有的属性都是final和private
* 不提供setter方法
* 类是final的，或者所有的方法是final修饰的

## java字符串

字符串内容比较使用equal方法
字符串对象即指针使用==

在程序运行当中如果需要大量地对字符串进行加法操作，建议使用StringBuilder，StringBuffer
